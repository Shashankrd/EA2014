from __future__ import division
# large network -- plot for best fitness
__author__ = 'priyanksanghavi'

# change initial population -- links... only nodes nearby can have link


import numpy as np
import csv
import matplotlib.pyplot as plt

np.random.seed(1234)

numberOfNodes = 5000
sample_space_size = 100
pop_size = 100
generations = 0
gen = []

source = 2354
destination = 1768

p = 0
pc = 0.9
pm = 0.1

length = 100
offspring_final_length = 3*pop_size
sample_fitness = [0 for x in range(sample_space_size)]
fitness = [0 for x in range(3*pop_size)]
temp_population = [[0 for x in range(length)] for y in range(sample_space_size)]
population = [[0 for x in range(length)] for y in range(pop_size)]
offspring = [[0 for x in range(length)]for y in range(3*pop_size)]
offspring_fitness = [[0 for x in range(length)]for y in range(3*pop_size)]
fitness_with_nodes = [0 for x in range(5*pop_size)]
final_fitness = [0 for x in range(3*pop_size)]
best_fitness = [0 for x in range(100)]
mean_fitness = [0 for x in range(100)]


# weights = [[x for x in range(numberOfNodes)] for y in range(numberOfNodes)]
weights = [[0 for x in range(numberOfNodes)] for y in range(numberOfNodes)]

for i in range(numberOfNodes):
    weights[i][i] = np.random.randint(50, 1000)

    for j in range(0,i):
            weights[i][j] = np.random.randint(50,1000)
            weights[j][i] = weights[i][j]




# ifile  = open('p2p-Gnutella08.csv', "rb")
# reader = csv.reader(ifile)
#
# data = [[eval(row[0]), eval(row[1])] for row in reader]

# data = np.genfromtxt("p2p-Gnutella08.csv",delimiter=",")

# print data[0][1]
# print data[1][0]

# #
links = [[0 for x in range(numberOfNodes)] for y in range(numberOfNodes)]

# for i in range(len(data)):
#     links[data[i][0]-1][data[i][1]-1] = 1
#     links[data[i][1]-1][data[i][0]-1] = 1
#
# links = np.random.randint(0, 2, size = (numberOfNodes, numberOfNodes))
#
for i in range(numberOfNodes):
    for j in range(numberOfNodes):
        if weights[i][j] <= 200:
            links[i][j] = 1
            links[j][i] = 1
# print links[source-1][destination-1]
# print weights[source-1][destination-1]

def init_population():
    global population
    global fitness

    #generate population of length 1000
    for i in range(0, sample_space_size):
        # print 'hi'
        # while temp_population[i][length-1] != destination or temp_population[i][length-1] != 0:
            k = 0
            temp_population[i][0] = source
            for j in range(1, length):
                if k == 0:
                    # if temp_population[i][j-1]-1 >= sample_space_size or destination-1 >= length:
                    #     print 'welcome'
                    #     print temp_population[i][j-1]-1
                    #     print destination-1
                    if links[temp_population[i][j-1]-1][destination-1] == 1:
                        temp_population[i][j] = destination
                        k = 1
                    else:
                        temp_population[i][j] = np.random.randint(1, (numberOfNodes+1))
                        while temp_population[i][j] == source or links[temp_population[i][j - 1] - 1][temp_population[i][j] - 1] == 0:
                            temp_population[i][j] = np.random.randint(1, (numberOfNodes+1))

                else:
                    temp_population[i][j] = 0

            # print temp_population[i]

    population = temp_population
    fitness = sample_fitness

    #remove loops
    for i in range(pop_size):
        # print str(i) + " population = " + str(population[i])
        for z in range(0, 10):
            for k in range(length):
                for l in range(k+1, length):
                    if population[i][k] == population[i][l]:
                        #print 'hi'
                        #for m in range(20-l-1, k+1, -1):
                        temp = l
                        for m in range(k+1, length-temp):
                            # print 'hi'
                            temp += 1
                            population[i][m] = population[i][temp]
                            #temp += 1
                            if population[i][m] == 0:
                                break

                        for n in range(temp, length):
                            population[i][n] = 0
                        break



    #find fitness of initial population
    for i in range(0, pop_size):
        sample_fitness[i] = 0
        j = 0
        print population[i]
        while population[i][j] != destination and j!=length:
            temp = population[i][j]
            temp1 = population[i][j + 1]
            fitness[i] += weights[temp - 1][temp1 - 1]
            j += 1
            del temp
            del temp1
        # print str(i) + ' ' + str(population[i])
        # print fitness[i]



def crossover():
    global pc
    global k
    global population
    global source
    global destination
    global offspring_final_length
    global offspring
    global p

    p = 0
    for l in range(pop_size):
        prob = np.random.uniform(0.0, 1.0)
        if prob < pc:
            k = 0
            parent1 = np.random.randint(0, pop_size)
            parent2 = np.random.randint(0, pop_size)
            while parent1 == parent2:
                parent2 = np.random.randint(0, pop_size)
            # print 'Parent1 -- ' + str(parent1) + ' Parent2 -- ' + str(parent2)
            # print 'Parent 1 is ' + str(population[parent1])
            i = 0
            j = 0
            # offspring[l*4] = final_population[parent1]
            # offspring[l*4+1] = final_population[parent2]
            # print final_population
            while population[parent1][i] != destination:
                while population[parent2][j] != destination:
                    if population[parent1][i] == population[parent2][j] and population[parent1][i] != source:
                        #do crossover and break with k=1
                        temp1 = population[parent1][i:]
                        temp2 = population[parent2][j:]
                        # print 'temp1 = ' + str(temp1)
                        # print 'temp2 = ' + str(temp2)
                        offspring[p*2] = population[parent1][0:i] + temp2
                        offspring[p*2+1] = population[parent2][0:j] + temp1
                        p += 1
                        k = 1
                        # print offspring[p*2]
                        break

                    else:
                        j += 1
                if k == 1:
                    break
                i += 1
                j = 0
    # print 'p is ' + str(p)
    for q in range(pop_size):
        offspring[p+q] = population[q]
        offspring_final_length = p+q
    #print 'Exiting crossover'
    # print offspring_final_length
    # print '\n'
    # for i in range(offspring_final_length):
    #     print offspring[i]
    # print offspring_final_length


def mutation():
    global pm
    global offspring_final_length
    global source
    global destination

    for i in range(offspring_final_length):
        brk = 0
        temp = 1
        mut = np.random.uniform(0.0, 1.0)

        if mut < pm:
            j = 0
            var = 0
            # print 'mutation'
            while offspring[i][j] != destination:
                temp += 1
                j += 1
                # print j
            if temp == 2:
                continue


            temp1 = np.random.randint(1, temp-1)
            value = offspring[i][temp1]
            next1 = offspring[i][temp1+1]
            previous = offspring[i][temp1-1]
            # print offspring[i]
            # print 'value = ' + str(value)+ ' next = ' + str(next1) + ' previous = ' + str(previous)
            mut1 = np.random.randint(1, numberOfNodes+1)
            while links[mut1-1][next1-1] == 0 or links[mut1-1][previous-1] == 0 or value == mut1 or mut1 == source:
                mut1 = np.random.randint(1, numberOfNodes+1)
                brk += 1
                if brk == int(numberOfNodes/2):
                    var += 1
                    break

            if var == 0:
                # print 'mut1 = ' + str(mut1)
                # print ' hello '
                # print offspring[i]
                offspring[i][temp1] = mut1
                # print offspring[i]
                # print offspring[i]
                #remove loops
                for z in range(0, 10):
                    for k in range(temp):
                        for l in range(k+1, temp):
                            if offspring[i][k] == offspring[i][l]:
                                #print 'hi'
                                #for m in range(20-l-1, k+1, -1):
                                temp2 = l
                                for m in range(k+1, temp-temp2):
                                    # print 'hi'
                                    temp2 += 1
                                    offspring[i][m] = offspring[i][temp2]
                                    #temp += 1
                                    if offspring[i][m] == 0:
                                        break

                                for n in range(temp, length):
                                    # print n
                                    offspring[i][n] = 0
                                break
                # print offspring[i]
            # print '\n'

def pop_fitness():
    global offspring_final_length
    global fitness_with_nodes
    global offspring_fitness

    for i in range(offspring_final_length):
        if offspring[i][0] != 0:
            offspring_fitness[i] = 0
            j = 0
            #print offspring[i]
            while offspring[i][j] != destination: #and j != numberOfNodes-1:
                temp = offspring[i][j]
                #print temp
                temp1 = offspring[i][j+1]
                #print j+1
                offspring_fitness[i] += weights[temp-1][temp1-1]
                j += 1
                del temp
                del temp1


def selection():
    global offspring_final_length
    global best_fitness
    global generations

    #sort ascending
    for i in range(offspring_final_length):
        for j in range(offspring_final_length - i - 1):
            if offspring_fitness[j] > offspring_fitness[j+1] != 0:# and fitness[j] != 0:
                temp = offspring_fitness[j]
                offspring_fitness[j] = offspring_fitness[j+1]
                offspring_fitness[j+1] = temp

                temp1 = offspring[j]
                offspring[j] = offspring[j+1]
                offspring[j+1] = temp1
        #print offspring[i]
    for i in range(pop_size):
        # temp = np.random.randint(0, offspring_final_length)
        population[i] = offspring[i]
        fitness[i] = offspring_fitness[i]
    # mean_fitness[generations] = np.mean(fitness)

    for i in range(pop_size):
        for j in range(pop_size - i - 1):
            if fitness[j] >= fitness[j+1]:
                temp = fitness[j]
                fitness[j] = fitness[j+1]
                fitness[j+1] = temp

                temp1 = population[j]
                population[j] = population[j+1]
                population[j+1] = temp1

    best_fitness[generations] = fitness[1]
    print fitness[1]
    # print 'Best is  ' + str(population[1]) + ' -- >  ' + str(fitness[1])
    # print str(population[2]) + '-- > ' + str(fitness[2])


def main():
    global generations
    global source
    global destination

    # for i in range(10):
    #
    #     source = np.random.randint(numberOfNodes)
    #     print source
    #     destination = np.random.randint(numberOfNodes)
    #     print destination
    init_population()

    while generations != 100:
        crossover()
        mutation()
        pop_fitness()
        selection()
        gen.append(generations)
        generations += 1
    print population[1]
    # print links[source-1][destination-1]
    # print weights[source-1][destination-1]
    print '\n\n\n'
    plt.plot(np.array(gen[:generations]), np.array(best_fitness[:generations]),label='Best Fitness')
    plt.plot(np.array(gen[:generations]), np.array(mean_fitness[:generations]),label='Mean Fitness')
    plt.show()


if __name__ == "__main__":
    main()
